\documentclass[]{aiaa-tc} % insert '[draft]' option to show overfull boxes

 \title{Gradient-Based Optimization on Large Design Spaces with Graph-Based Problem Formulation In OpenMDAO}
        
\author{
  Tristan A. Hearn,%
     \thanks{Aerospace Engineer, MDAO Branch, Mail Stop 5-10, AIAA Member}
  \ Kenneth T. Moore,%
     \thanks{Senior Systems Engineer, MDAO Branch, Mail Stop 500-105, AIAA Senior Member} 
  \ Justin Gray,%
     \thanks{Aerospace Engineer, MDAO Branch, Mail Stop 5-11, AIAA Member}
   \\
  {\normalsize\itshape
  NASA Glenn Research Center, Cleveland, OH}  \\
  John T. Hwang,%
  \thanks{Ph.D. Candidate, Department of Aerospace Engineering, AIAA Student Member}
  \ Joaquim R. R. A. Martins%
  \thanks{Associate Professor, Department of Aerospace Engineering, AIAA Associate Fellow}
  \\
  {\normalsize\itshape
   University of Michigan, Ann Arbor, Michigan, 48109, United States}
}

\AIAAconference{Multidisciplinary Design Optimization Specialist Conference}
\AIAAcopyright{\AIAAcopyrightD{2012}}


% Define commands to assure consistent treatment throughout document
\newcommand{\eqnref}[1]{(\ref{#1})}
\newcommand{\class}[1]{\texttt{#1}}
\newcommand{\package}[1]{\texttt{#1}}
\newcommand{\file}[1]{\texttt{#1}}
\newcommand{\BibTeX}{\textsc{Bib}\TeX}

\setlength{\abovecaptionskip}{0pt}
\setlength{\belowcaptionskip}{0pt}

\usepackage{setspace}

\usepackage{graphicx}
\usepackage{wrapfig}
\usepackage{caption} 
\usepackage{amsmath}
\usepackage{lscape}
\usepackage{hyperref}
\usepackage{minted}
\usepackage{color}
\usepackage{appendix}
\usepackage[section]{placeins}

\newcommand{\txt}{\textrm}


\captionsetup[figure]{margin=5pt,font=small,labelfont=bf,textfont=bf,justification=justified,}
%\captionsetup[wrapfigure]{margin=5pt,font=small,labelfont=bf,justification=justified,singlelinecheck=off}
\captionsetup[table]{margin=5pt,font=small,labelfont=bf,textfont=bf,justification=justified,position=top}

\bibliographystyle{aiaa}

\usepackage{lettrine}
\usepackage{verbatim}

\begin{document}

  \maketitle
   
  \begin{abstract}

  \end{abstract}

  \section{Introduction}

    Many of today's the most interesting design problems involve very large design spaces with 100's or 1000's of 
    design variables. Large design spaces are often approached through the use of gradient based optimization 
    analytic derivatives to achieve highly scalable solution strategies. For instance, adjoint based gradient 
    methods have allowed CFD based shape optimization to tackle problems with 100's of design variables. [Cite Juan's Groups
    work here]. Coupled Aero-structural optimization is another area where gradient based optimization methods have 
    been employed. [Cite Martins groups work here]. Although these problems have large design spaces, 
    they include only a few disciplines (i.e. Geometry, Aerodynamics, Structures). The relative simplicity of 
    the problem formulation make it feasible to use custom implementations tailored to a specific problem. Naturally however, 
    this approach also limits the problem complexity that can be addressed with current MDAO methods. 

    On the other end of the spectrum, traditional systems analysis models can be composed of 10's to 100's of disciplines, 
    but usually work with lower fidelity analyses. These problems commonly contain a very high degree of interdisciplinary 
    coupling, while working with lower fidelity analyses. These more complex problem formulations are much more difficult to compute 
    analytic derivatives for at the system level, even if each discipline could provide its own partial derivatives. So many 
    problems are solved using a finite difference approach, which restricts the size of the design space. 

    If you placed complexity on the Y-axis and Fidelity on the X-axis, then the problem spectrum resemble the notional 
    cartoon in Figure \ref{fig:complexity_cartoon}. In this diagram, there is a gap between the lower and higher fidelity 
    type problems is indicative of the bifurcation in methods used to solve each type of problem currently. This gap begs the 
    question, ``How should you appraoch a problem of medium complexity and medium fidelity?'' We propose that the answer to this
    dilemma is to develop a more general manner of implementing MDAO problems that can be applied to any problem across the entire 
    space of complexity and fidelity.  

    \begin{figure}[!htb]\begin{center}
      \includegraphics[width=.5\textwidth]{images/complexity_cartoon}
      \caption{ Notional spectrum of design problems currently being addressed. \label{fig:complexity_cartoon}}
    \end{center}\end{figure}

    In this work we demonstrate how OpenMDAO, an open-source framework, such a general 
    solution to constructing and solving complex problems with large design spaces using the 
    same MDAO methods commonly applied to the the shape optimization and aero-structural optimization 
    problems. OpenMDAO achieves this by providing three key features: 

    \begin{enumerate}
      \item Automatic handling of arbitrary interdisciplinary coupling 
      \item Automatic formulation of gradients, including coupled derivatives, given arbitrary coupling
      \item Efficient operation in a high performance computing environment with distributed data
    \end{enumerate}

    \begin{comment}
      \begin{enumerate}
        \item Combining analytic derivatives with finite difference in a mixed derivatives environment
        \item Efficient solving for the coupled derivatives at the system level 
        \item Assembly of the full gradient from the partial derivatives of each discipline
        \item Flexbility via separation of problem formulation from solution strategy 
        \item Simple implementation for multi-point design problems
      \end{enumerate}
    \end{comment}

    To demonstrate these capabilities, we present two different problems representing different levels of 
    complexity and fidelity, solved within the OpenMDAO framework. The fist problem is the design of a small 
    satellite platform for taking weather measurements in the thermosphere, called CADRE. The CADRE problem has a 
    complex problem formulation with XX disciplines and over 25000 design variables, but is lower fidelity and can 
    be run on a single processor. This problem demonstrates that OpenMDAO successfully bridges the gap shown 
    in Figure \ref{fig:complexity_cartoon}. The second problem is an aero-structural design of the Common Research 
    Model wing, using CFD and FEA. This problem shows that OpenMDAO can work with problems that demand higher fidelity 
    simulations with parallel communication and distributed data. 

  \section{Dependency Graph}

    OpenMDAO maintains a monolithic data connectivity graph between all 
    variables and components in the model, called the dependency graph.
    Using efficient graph traversal algorithms, OpenMDAO provides a number of 
    features which make it easier to implement large scale design problems. 

    \begin{itemize}
      \item Determination of component execution order via path finding.
      \item Identification of interdisciplinary coupling through cycle detection.
      \item Construction of a minimum-sized linear system to solve for gradients.
    \end{itemize}

    This section will describe the graph structure used to represent problem formulation in OpenMDAO, 
    then discuss in detail how graph traversal algorithms are used to provide features. OpenMDAO relies
    on the NetworkX \cite{hagberg-2008-exploring} python package for implementation of each of 
    the algorithms. 
      

    \subsection{Graph Structure}
    The graph utilizes the structure proposed by 
    Pate et. al \cite{graph_problem2013} and represents the complete problem formulation as 
    defined by the user. In a dependency graph, each component and all variable inputs and outputs of that component are 
    represented by nodes with directed edges between them describing their dependencies on each other. 
    Figure \ref{fig:sellar_graph} shows a sample graph for the Sellar Problem \cite{AIAA:sellar} 
    given in eqn. \ref{eqn:sellar_formulation}.  

    \begin{align}
        \txt{given} & \ \ y_1 = D_1(x_1,y_2,z_1,z_2) \notag
        \\      & \ \ y_2 = D_2(y_1,z_1,z_2) \notag
        \\\txt{min.} &\ \ F(x_1,y_1,y_2,z_2) \notag
        \\\txt{w.r.t.} & \ \ x_1,y_1,y_2,z_1,z_2 \notag
        \\\txt{s.t.} & \ \ G_1(y_1) \geq 0 \notag
        \\     & \ \ G_2(y_2) \geq 0
        \label{eqn:sellar_formulation}
    \end{align}


    \begin{figure}[!htb]\begin{center}
      \includegraphics[width=.8\textwidth]{images/sellar_cycles}
      \caption{ Dependency graph for the Sellar problem. \label{fig:sellar_graph}}
    \end{center}\end{figure}

    In the original graph syntax, a single node is given for every variable. This holds true for the graph 
    within OpenMDAO, with only one minor caveat. In the case of any hierarchical variables, such as arrays
    or VariableTrees, one variable node is created to represent the overall variable with additional nodes
    created if any specific sub-variable is referenced (e.g., some slice of an array or some child variable from a 
    VariableTree). Figure \ref{fig:subvars} shows how the sub-variable nodes relate to their parent variables. 

     \begin{figure}[!htb]\begin{center}
      xxxxxxx\\xxxxxxx\\xxxxxxx\\xxxxxxx\\xxxxxxx\\xxxxxxx\\
      \caption{ Example graph with child nodes for sub-variables \label{fig:subvars}}
    \end{center}\end{figure}

    By representing hierarchical data as a single node, we help keep the overall size of the graph manageable 
    when large chunks of data are being communicated. However, if some small sub-set of that data needs to be 
    used somewhere it is not correct to indicate a dependence on the entire chunk of data. So in this case, a 
    single new node representing the sub-variable is created with its own dependence on the parent variable. 
    This book keeping becomes particularly important for when the graph is used to calculate derivatives or 
    manage the partitioning of distributed data. 

    \subsection{Determining Execution Order}
    The OpenMDAO framework uses a dependency graph to determine component execution order and to
    drive the process of invalidation, which finds the minimum set of components that needs to
    be re-executed when a set of inputs change. (ref: last OpenMDAO paper.) A dependency graph
    can also identify cycles in the graph, and hence a cycle in the dataflow that must be resolved
    by a solver. Similarly, the graph can also be used to examine the potential for parallelism at
    the component level.

    \subsection{Relevant Set Identification and Usage}
    Given the dependency graph for any problem, in order to set up a design optimization the user
    must first specify a set of design variables, objectives, and constraints. Once those are given, 
    the set of all relevant components and variables that lie between the design variables and the 
    objectives and constraints can be identified. This path is a sub-graph of the full 
    dependency graph that is necessary for the given problem formulation, and contains all the components 
    that execute when the optimizer requests a function evaluation. 

    It is also useful for setting up and solving the coupled derivative system when the optimizer requests
    a gradient evaluation. Gradients are computed using Martins and Hwang's NSE method\cite{Martins2012}. This 
    method constructs a single linear system which can be solvef for the total derivatives of any variable with 
    respect to any other variable, given all of the partial derivatives. The linear system has the same dimension 
    as the number of variables in your problem formulation. Since the cost of solving linear systems grows very 
    quickly with the number of variables, it is highly desirable to shrink that number if at all possible. 
    Although you could include the full set of variables from the entire dependency graph, any variables that do 
    not appear in the relevant set would have no actual impact on the solution. By using the relevant set 
    of variables identified by the sub-graph of any given problem, OpenMDAO can  
    reduce the size of the linear system to its minimum possible size and improve the efficiency 
    of solving for the necessary derivatives. 

    OpenMDAO supports calculating derivatives in two ways: direct and adjoint. The direct method performs 
    one linear solve for each design variable, and yields derivatives of all other variables with respect to 
    to that one design variable. With the adjoint method, one linear solve is performed for each constraint and 
    objective value, each one yielding the full gradient for that quantity of interest. Whether you use the forward 
    or adjoint method of solving for derivatives, the relevant sub-graph for each linear solve performed should be 
    kept as small as possible. So further efficiency gains can be made by calculating a relevant set for each 
    of the individual linear solves.

    \subsection{Cycle Detection and Usage}
    Pate et. al indicate that within a dependency graph, the presence of cycles indicates coupling between 
    the components in the cycle \cite{graph_problem2013}. A cycle can consist of two or more components, and 
    one component may be part of more than one cycle. 

    In formal terms, cycles exist in a graph when a group of nodes are strongly connected. The NetworkX package 
    provides an implementation of Tarjans algorithm for finding sets of strongly connected 
    components\cite{tarjan1972depth,nuutila1994finding}. Once found, the presence of these cycles 
    have an impact on how any given model is solved. Firstly during normal execution, these cycles 
    need to be converged with a numerical solver such as Gauss-Seidel or Newton based. 

    In addition these cycles are used to form the correct linear system to solve for system level coupled 
    derivatives. The linear system used is built according to the methods developed by Martins and Hwang
    for solving for derivatives in the general case with both direct and residual 
    components in the system \cite{Martins2012}.

    \subsection{Gradient Calculation}
    \subsection{Mixed Analytic and Finite Difference Gradients}

  \section{CADRE Problem Formulation}

  \section{CADRE Results}

  \section{Aero-Structural Problem Formulation}

  \section{Aero-Structural Results}

  \section{Conclusion}
 
  \bibliography{references}

\end{document}
